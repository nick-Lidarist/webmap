<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }

        function processAllXlsxFilesInSharedFolder() {
          const sharedFolderId = "1LYwz7HwdpynDmYUcYrwtvy_eHNSOFj0X"; // Your shared folder ID
          const rootFolder = DriveApp.getFolderById(sharedFolderId);
          const results = [];

          // Recursively walk through all folders
          function walkFolder(folder) {
            const files = folder.getFiles();
            while (files.hasNext()) {
              const file = files.next();
              if (file.getMimeType() === MimeType.MICROSOFT_EXCEL) {
                const csv = processXlsxFile(file);
                results.push({ filename: file.getName(), csv });
              }
            }

            const subfolders = folder.getFolders();
            while (subfolders.hasNext()) {
              walkFolder(subfolders.next());
            }
          }

          walkFolder(rootFolder);
          return results; // Array of { filename, csv }
        }

        function processXlsxFile(file) {
          try {
            const blob = file.getBlob();
            const base64Data = Utilities.base64Encode(blob.getBytes());
            const workbook = XLSX.read(base64Data, { type: 'base64' });
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];

            const filledCell = cell => cell !== null && cell !== undefined && cell !== '';
            const jsonData = XLSX.utils.sheet_to_json(worksheet, {
              header: 1,
              blankrows: false,
              defval: ''
            });

            const filteredData = jsonData.filter(row => row.some(filledCell));

            let headerRowIndex = filteredData.findIndex((row, index) =>
              row.filter(filledCell).length >= (filteredData[index + 1]?.filter(filledCell).length || 0)
            );
            if (headerRowIndex === -1 || headerRowIndex > 25) headerRowIndex = 0;

            const csvSheet = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
            const csv = XLSX.utils.sheet_to_csv(csvSheet, { header: 1 });

            return csv;
          } catch (e) {
            Logger.log(`‚ùå Error processing file "${file.getName()}": ${e}`);
            return "";
          }
        }

        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Plot Features Containing 'Áßü' with Confirmation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; }
    #map { width: 100%; height: 100%; }

    /* Folder selection button */
    /*
    #folderLabel {
      position: absolute; top: 10px; left: 50px; z-index: 1000; 
      background: #ffffff; padding: 10px 15px; border-radius: 6px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.15); border: 1px solid #ddd; 
      font-size: 14px; cursor: pointer; transition: background 0.2s;
      display: flex; align-items: center; gap: 8px;
    }
    #folderLabel:hover { background: #f8f9fa; }
    #folderLabel::before { content: "üìÅ"; font-size: 16px; }

    #fileInput { display: none; }
    */
    /* Export button */
    #exportButton {
      position: absolute; top: 10px; left: 50px; z-index: 1000; 
      background: #ffffff; padding: 10px 15px; border-radius: 6px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.15); border: 1px solid #ddd; 
      font-size: 14px; cursor: pointer; transition: background 0.2s;
    }
    #exportButton:hover { background: #f8f9fa; }

    #loadDataBtn {
      position: fixed;
      top: 10px;
      left: 50px;
      padding: 10px 20px;
      background-color: #0078D4;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      z-index: 1000;
    }

    #loadDataBtn:hover {
      background-color: #005A9E;
    }


    /* Loading indicator */
    #loading {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1001;
      background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); font-size: 14px; display: none;
    }

    /* Legend panel */
    #legend {
      position: absolute; top: 10px; right: 10px; z-index: 1000; 
      background: #ffffff; padding: 15px; border-radius: 8px; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 14px; 
      line-height: 1.5em; min-width: 150px;
    }
    #legend h3 {
      margin: 0 0 10px 0; font-size: 16px; color: #333;
      border-bottom: 1px solid #e0e0e0; padding-bottom: 5px; text-align: center;
    }
    .legend-item {
      display: flex; align-items: center; margin: 5px 0;
    }
    .legend-dot {
      width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; border: 1px solid rgba(0,0,0,0.2);
    }

    /* Popup styling */
    .leaflet-popup-content { max-height: 400px; overflow-y: auto; margin: 10px; font-size: 12px; }
    .leaflet-popup-content-wrapper { border-radius: 6px; }
    .popup-table { border-collapse: collapse; width: 100%; }
    .popup-table td { border: 1px solid #e0e0e0; padding: 6px; vertical-align: top; }
    .popup-table td.key { font-weight: bold; background: #f8f9fa; width: 30%; }
    .popup-img { max-width: 250px; max-height: 150px; width: auto; height: auto; margin-top: 10px; border-radius: 4px; border: 1px solid #ddd; }
    .confirm-checkbox { margin-top: 10px; }
  </style>
</head>
<body>

<!--label id="folderLabel" for="fileInput">Select Data Folder</label-->

<!--button id="loadDataBtn">Load Data</button-->
<!--input type="file" id="fileInput" webkitdirectory directory multiple /-->
<button id="exportButton" style="display: none;">Export to checked.json</button>
<div id="loading">Loading GeoJSON and images...</div>
<div id="legend">
  <h3>Features with 'Áßü'</h3>
  <div class="legend-item"><span class="legend-dot" style="background:red"></span>Âá∫Áßü</div>
  <div class="legend-item"><span class="legend-dot" style="background:orange"></span>ÊãõÁßü</div>
  <div class="legend-item"><span class="legend-dot" style="background:blue"></span>ÁßüÂîÆ</div>
  <div class="legend-item"><span class="legend-dot" style="background:green"></span>Verified Vacant Shop</div>
  <div class="legend-item"><span class="legend-dot" style="background:black"></span>Other (e.g., Áßü)</div>
</div>
<div id="map"></div>



<script>
  const map = L.map('map').setView([22.31, 114.17], 14);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> contributors &copy; <a href="https://carto.com/">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 20
  }).addTo(map);

  let currentLayer = null;
  let allFeatures = [];
  let featureToLayerMap = new Map();

  function escapeHtml(str) {
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }

  function getColorForText(feature) {
    const txt = feature.properties.text || '';
    if (feature.properties.confirmed_rent) return 'green';
    if (txt.includes('Âá∫Áßü')) return 'red';
    if (txt.includes('ÊãõÁßü')) return 'orange';
    if (txt.includes('ÁßüÂîÆ')) return 'blue';
    return 'black';
  }

  function buildPopup(properties, featureIndex) {
    let rows = '';
    Object.entries(properties).forEach(([key, value]) => {
      if (key !== 'image_data' && key !== 'confirmed_rent') {
        rows += `<tr><td class="key">${escapeHtml(key)}</td><td>${escapeHtml(String(value))}</td></tr>`;
      }
    });
    let imgHtml = properties.image_data ? `<div><img class="popup-img" src="${escapeHtml(properties.image_data)}" alt="Property image" onerror="this.style.display='none'"></div>` : '';
    let checkboxHtml = '';
    if (!properties.confirmed_rent && !['Âá∫Áßü', 'ÊãõÁßü', 'ÁßüÂîÆ'].some(k => properties.text.includes(k))) {
      checkboxHtml = `<div class="confirm-checkbox"><label><input type="checkbox" onchange="updateConfirmation(${featureIndex}, this.checked)"> Confirm as 'Áßü' feature</label></div>`;
    }
    return `<table class="popup-table">${rows}</table>${imgHtml}${checkboxHtml}`;
  }

  function updateConfirmation(featureIndex, isChecked) {
    allFeatures[featureIndex].properties.confirmed_rent = isChecked;
    const layer = featureToLayerMap.get(allFeatures[featureIndex]);
    if (layer) {
      const color = getColorForText(allFeatures[featureIndex]);
      layer.setStyle({
        color: color,
        fillColor: color
      });
    }
    document.getElementById('exportButton').style.display = allFeatures.length > 0 ? 'block' : 'none';
  }

  async function readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }

  async function readFileAsDataURL(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  async function processFolder(files) {
    const filesMap = new Map();
    files.forEach(file => filesMap.set(file.name, file));

    const geojsonFiles = files.filter(f => f.name.match(/\.(geojson|json)$/i));
    if (geojsonFiles.length === 0) {
      alert('No GeoJSON or JSON files found in the folder.');
      return null;
    }

    const geojsonPromises = geojsonFiles.map(async file => {
      try {
        const text = await readFileAsText(file);
        return JSON.parse(text);
      } catch (err) {
        console.warn(`Failed to parse ${file.name}:`, err);
        return null;
      }
    });

    const geojsons = (await Promise.all(geojsonPromises)).filter(g => g && g.type === 'FeatureCollection' && Array.isArray(g.features));
    if (geojsons.length === 0) {
      alert('No valid GeoJSON files found.');
      return null;
    }

    const aggregated = {
      type: 'FeatureCollection',
      features: []
    };
    geojsons.forEach((geojson, index) => {
      geojson.features.forEach(feature => {
        if (feature.geometry && feature.properties && feature.properties.text?.includes('Áßü')) {
          feature.properties.source = `GeoJSON_${index + 1}`;
          aggregated.features.push(feature);
        }
      });
    });

    const uniqueImagePaths = new Set(aggregated.features.map(f => f.properties.image_path).filter(Boolean));
    const imageCache = new Map();
    const imagePromises = Array.from(uniqueImagePaths).map(async path => {
      const imgFile = filesMap.get(path);
      if (imgFile) {
        try {
          const dataUrl = await readFileAsDataURL(imgFile);
          imageCache.set(path, dataUrl);
        } catch (err) {
          console.warn(`Failed to read image ${path}:`, err);
        }
      }
    });
    await Promise.all(imagePromises);

    aggregated.features.forEach(f => {
      if (f.properties.image_path && imageCache.has(f.properties.image_path)) {
        f.properties.image_data = imageCache.get(f.properties.image_path);
      }
    });

    return aggregated;
  }





  async function processGeoJsonFolder() {
    const folderId = "1LYwz7HwdpynDmYUcYrwtvy_eHNSOFj0X";
    const filesMap = new Map();

    // List all files in the folder
    const listResponse = await gapi.client.drive.files.list({
      q: `'${folderId}' in parents and trashed = false`,
      fields: "files(id, name, mimeType)"
    });

    const files = listResponse.result.files;
    files.forEach(file => filesMap.set(file.name, file));

    // Filter for .geojson or .json files
    const geojsonFiles = files.filter(f => f.name.match(/\.(geojson|json)$/i));
    if (geojsonFiles.length === 0) {
      alert("No GeoJSON or JSON files found.");
      return null;
    }

    // Download and parse GeoJSON files
    const geojsons = await Promise.all(geojsonFiles.map(async file => {
      try {
        const response = await gapi.client.drive.files.get({
          fileId: file.id,
          alt: "media"
        });
        const parsed = JSON.parse(response.body);
        if (parsed.type === "FeatureCollection" && Array.isArray(parsed.features)) {
          return parsed;
        }
      } catch (err) {
        console.warn(`Failed to parse ${file.name}:`, err);
      }
      return null;
    }));

    const validGeojsons = geojsons.filter(g => g);
    if (validGeojsons.length === 0) {
      alert("No valid GeoJSON files found.");
      return null;
    }

    // Aggregate filtered features
    const aggregated = {
      type: "FeatureCollection",
      features: []
    };

    validGeojsons.forEach((geojson, index) => {
      geojson.features.forEach(feature => {
        if (
          feature.geometry &&
          feature.properties &&
          feature.properties.text &&
          feature.properties.text.includes("Áßü")
        ) {
          feature.properties.source = `GeoJSON_${index + 1}`;
          aggregated.features.push(feature);
        }
      });
    });

    // Load image data
    const uniqueImagePaths = new Set(
      aggregated.features.map(f => f.properties.image_path).filter(Boolean)
    );

    const imageCache = new Map();
    await Promise.all(Array.from(uniqueImagePaths).map(async path => {
      const imgFile = filesMap.get(path);
      if (imgFile) {
        try {
          const response = await fetch(`https://www.googleapis.com/drive/v3/files/${imgFile.id}?alt=media`, {
            headers: {
              Authorization: `Bearer ${gapi.auth.getToken().access_token}`
            }
          });

          const blob = await response.blob();
          const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });

          imageCache.set(path, base64); // base64 already includes mime type
        } catch (err) {
          console.warn(`Failed to read image ${path}:`, err);
        }
      }
    }));

    // Embed image data into features
    aggregated.features.forEach(f => {
      const path = f.properties.image_path;
      if (path && imageCache.has(path)) {
        f.properties.image_data = imageCache.get(path);
      }
    });

    return aggregated;
  }

  function exportToJson() {
    const outputGeojson = {
      type: 'FeatureCollection',
      features: allFeatures.map(feature => {
        const { image_data, ...properties } = feature.properties;
        return {
          type: feature.type,
          geometry: feature.geometry,
          properties: properties
        };
      })
    };
    const blob = new Blob([JSON.stringify(outputGeojson, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'checked.json';
    a.click();
    URL.revokeObjectURL(url);
  }


  async function loadDataFromManifest() {
    document.getElementById('loading').style.display = 'block';

    try {
      const response = await fetch("https://nick-Lidarist.github.io/webmap/manifest.json");
      const manifest = await response.json();

      const geojsonFiles = [...manifest.geojson, ...manifest.json];
      if (geojsonFiles.length === 0) {
        alert("No GeoJSON or JSON files found in manifest.");
        return;
      }

      const geojsons = await Promise.all(geojsonFiles.map(async url => {
        try {
          const res = await fetch(url);
          const parsed = await res.json();
          if (parsed.type === "FeatureCollection" && Array.isArray(parsed.features)) {
            return parsed;
          }
        } catch (err) {
          console.warn(`Failed to load ${url}:`, err);
        }
        return null;
      }));

      const validGeojsons = geojsons.filter(g => g);
      if (validGeojsons.length === 0) {
        alert("No valid GeoJSON files found.");
        return;
      }

      const aggregated = {
        type: "FeatureCollection",
        features: []
      };

      validGeojsons.forEach((geojson, index) => {
        geojson.features.forEach(feature => {
          if (
            feature.geometry &&
            feature.properties &&
            feature.properties.text &&
            feature.properties.text.includes("Áßü")
          ) {
            feature.properties.source = `GeoJSON_${index + 1}`;
            aggregated.features.push(feature);
          }
        });
      });

      allFeatures = aggregated.features;
      featureToLayerMap.clear();

      if (currentLayer) {
        map.removeLayer(currentLayer);
      }

      currentLayer = L.geoJSON(aggregated, {
        pointToLayer: (feature, latlng) => {
          const color = getColorForText(feature);
          return L.circleMarker(latlng, {
            radius: 8,
            fillOpacity: 0.85,
            stroke: true,
            weight: 2,
            color: color,
            fillColor: color
          });
        },
        onEachFeature: (feature, layer) => {
          const featureIndex = allFeatures.findIndex(f => f === feature);
          featureToLayerMap.set(feature, layer);
          layer.bindPopup(buildPopup(feature.properties, featureIndex), { maxWidth: 300 });
        }
      }).addTo(map);

      map.fitBounds(currentLayer.getBounds().pad(0.1));
      document.getElementById('exportButton').style.display = allFeatures.length > 0 ? 'block' : 'none';

    } catch (err) {
      alert(`Error loading data from GitHub: ${err.message}`);
      console.error(err);
    } finally {
      document.getElementById('loading').style.display = 'none';
    }
  }

  // üöÄ Auto-run when page is ready
  window.addEventListener("DOMContentLoaded", loadDataFromManifest);




  /*
  document.getElementById('fileInput').addEventListener('change', async e => {
    const files = Array.from(e.target.files);
    if (files.length === 0) return;

    document.getElementById('loading').style.display = 'block';

    try {
      const geojson = await processFolder(files);
      if (!geojson || geojson.features.length === 0) {
        alert('No features containing "Áßü" found in the GeoJSON files.');
        return;
      }

      allFeatures = geojson.features;
      featureToLayerMap.clear();

      if (currentLayer) {
        map.removeLayer(currentLayer);
      }

      currentLayer = L.geoJSON(geojson, {
        pointToLayer: (feature, latlng) => {
          const color = getColorForText(feature);
          return L.circleMarker(latlng, {
            radius: 8,
            fillOpacity: 0.85,
            stroke: true,
            weight: 2,
            color: color,
            fillColor: color
          });
        },
        onEachFeature: (feature, layer) => {
          const featureIndex = allFeatures.findIndex(f => f === feature);
          featureToLayerMap.set(feature, layer);
          layer.bindPopup(buildPopup(feature.properties, featureIndex), { maxWidth: 300 });
        }
      }).addTo(map);

      map.fitBounds(currentLayer.getBounds().pad(0.1));
      document.getElementById('exportButton').style.display = allFeatures.length > 0 ? 'block' : 'none';
    } catch (err) {
      alert(`Error processing folder: ${err.message}`);
      console.error(err);
    } finally {
      document.getElementById('loading').style.display = 'none';
      document.getElementById('fileInput').value = '';
    }
  });
  */
  document.getElementById('exportButton').addEventListener('click', exportToJson);
</script>
</body>
</html>